package dev.steshko.kwire.fir

import dev.steshko.kwire.BeanConfig
import dev.steshko.kwire.BeanSource
import dev.steshko.kwire.KWireDeclarationKey
import dev.steshko.kwire.managerClassId
import dev.steshko.kwire.util.fqnToPropName
import dev.steshko.kwire.util.getClassSymbolFromFqn
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.getAnnotationByClassId
import org.jetbrains.kotlin.fir.expressions.FirLiteralExpression
import org.jetbrains.kotlin.fir.extensions.ExperimentalTopLevelDeclarationsGenerationApi
import org.jetbrains.kotlin.fir.extensions.FirDeclarationGenerationExtension
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.MemberGenerationContext
import org.jetbrains.kotlin.fir.extensions.predicate.DeclarationPredicate
import org.jetbrains.kotlin.fir.extensions.predicate.LookupPredicate
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.plugin.createMemberProperty
import org.jetbrains.kotlin.fir.plugin.createTopLevelClass
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.constructType
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

class KWireManagerFirGenerator(
    session: FirSession,
    private val beans: MutableList<BeanConfig>
) : FirDeclarationGenerationExtension(session) {
    companion object {
        const val BEAN_ANNOTATION_FQN = "dev.steshko.kwire.Bean"
        /**
         * Predicate matches anything annotated with @Bean
         */
        private val BEAN_PREDICATE = DeclarationPredicate.create {
            annotated(FqName(BEAN_ANNOTATION_FQN))
        }
    }

    override fun FirDeclarationPredicateRegistrar.registerPredicates() {
        register(BEAN_PREDICATE)
    }
    @ExperimentalTopLevelDeclarationsGenerationApi
    override fun generateTopLevelClassLikeDeclaration(classId: ClassId): FirClassLikeSymbol<*>? {
        if (classId != managerClassId) return super.generateTopLevelClassLikeDeclaration(classId)

        return createTopLevelClass(
            classId = managerClassId,
            key = KWireDeclarationKey,
            classKind = ClassKind.OBJECT
        ).symbol
    }

    /**
     * Called with names from [getCallableNamesForClass] [callableId.callableName]
     */
    override fun generateProperties(
        callableId: CallableId,
        context: MemberGenerationContext?
    ): List<FirPropertySymbol> {
        val owner = context?.owner ?: return emptyList()

        return listOf(
            createMemberProperty(
                owner = owner,
                key = KWireDeclarationKey,
                name = callableId.callableName,
                returnType = session.getClassSymbolFromFqn(beans.find { it.name == callableId.callableName.identifier }!!.fqName)!!.constructType()
            ).symbol
        )
    }

    /**
     * Compiler calls this method for every class
     * @return additional names of callable names (properties, functions) etc, these will be used to call [generateProperties] [generateFunctions]
     *
     */
    override fun getCallableNamesForClass(classSymbol: FirClassSymbol<*>, context: MemberGenerationContext): Set<Name> {
        if (classSymbol.classId != managerClassId)
            return emptySet()

        session.predicateBasedProvider.getSymbolsByPredicate(
            LookupPredicate.AnnotatedWith(setOf(FqName(BEAN_ANNOTATION_FQN)))
        ).forEach { beanAnnotatedClassSymbol ->
            if (beanAnnotatedClassSymbol !is FirClassLikeSymbol<*>) return@forEach

            beanAnnotatedClassSymbol.lazyResolveToPhase(FirResolvePhase.ANNOTATION_ARGUMENTS)
            val beanAnnotation = beanAnnotatedClassSymbol.getAnnotationByClassId(
                ClassId.topLevel(FqName(BEAN_ANNOTATION_FQN)),
                session
            ) ?: return@forEach

            val nameArgument =
                (beanAnnotation.argumentMapping.mapping[Name.identifier("name")] as? FirLiteralExpression)?.value as String?

            val fqName = beanAnnotatedClassSymbol.classId.asString().replace("/", ".")
            // Removing bean generated by ANNOTATION with same FQN as this should be impossible
            beans.removeAll { it.source == BeanSource.ANNOTATION && it.fqName == fqName }

            beans.add(BeanConfig(
                fqName = fqName,
                name = if (nameArgument.isNullOrBlank()) fqName.fqnToPropName() else nameArgument,
                source = BeanSource.ANNOTATION
            ))
        }
        return beans.map {
            Name.identifier(it.name)
        }.toSet()
    }

    /**
     * Return top level classes to generate, these will be passed into [generateTopLevelClassLikeDeclaration]
     */
    @OptIn(ExperimentalTopLevelDeclarationsGenerationApi::class)
    override fun getTopLevelClassIds(): Set<ClassId> {
        return setOf(managerClassId)
    }

    override fun hasPackage(packageFqName: FqName): Boolean {
        return packageFqName == managerClassId.packageFqName
    }
}