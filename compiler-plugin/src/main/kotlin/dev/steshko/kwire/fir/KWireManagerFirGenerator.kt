package dev.steshko.kwire.fir

import dev.steshko.kwire.Bean
import dev.steshko.kwire.BeanSource
import dev.steshko.kwire.KWireDeclarationKey
import dev.steshko.kwire.beans.BeanConfigInternal
import dev.steshko.kwire.beans.BeanCreationMethod
import dev.steshko.kwire.managerClassId
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.getAnnotationByClassId
import org.jetbrains.kotlin.fir.extensions.ExperimentalTopLevelDeclarationsGenerationApi
import org.jetbrains.kotlin.fir.extensions.FirDeclarationGenerationExtension
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.MemberGenerationContext
import org.jetbrains.kotlin.fir.extensions.predicate.DeclarationPredicate
import org.jetbrains.kotlin.fir.extensions.predicate.LookupPredicate
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.packageFqName
import org.jetbrains.kotlin.fir.plugin.createMemberProperty
import org.jetbrains.kotlin.fir.plugin.createTopLevelClass
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.classId
import org.jetbrains.kotlin.fir.types.constructType
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

class KWireManagerFirGenerator(
    session: FirSession,
    private val beans: MutableList<BeanConfigInternal>
) : FirDeclarationGenerationExtension(session) {
    companion object {
        /**
         * Predicate matches anything annotated with @Bean
         */
        private val BEAN_PREDICATE = DeclarationPredicate.create {
            annotated(FqName(Bean::class.qualifiedName!!))
        }
    }

    override fun FirDeclarationPredicateRegistrar.registerPredicates() {
        register(BEAN_PREDICATE)
    }
    @ExperimentalTopLevelDeclarationsGenerationApi
    override fun generateTopLevelClassLikeDeclaration(classId: ClassId): FirClassLikeSymbol<*>? {
        if (classId != managerClassId) return super.generateTopLevelClassLikeDeclaration(classId)

        beans.removeAll { it.source == BeanSource.ANNOTATION }
        session.predicateBasedProvider.getSymbolsByPredicate(
            LookupPredicate.AnnotatedWith(setOf(FqName(Bean::class.qualifiedName!!)))
        ).forEach { beanAnnotatedSymbol ->
            beanAnnotatedSymbol.lazyResolveToPhase(FirResolvePhase.ANNOTATION_ARGUMENTS)
            val (beanCreationMethod, fqName) = when (beanAnnotatedSymbol) {
                is FirClassLikeSymbol<*> ->
                    BeanCreationMethod.CLASS_CONSTRUCTOR to beanAnnotatedSymbol.classId.asString().replace("/", ".")
                is FirNamedFunctionSymbol ->
                    BeanCreationMethod.TOP_LEVEL_FUNCTION to (beanAnnotatedSymbol.resolvedReturnTypeRef.coneType.classId?.asString()?.replace("/", ".") ?: return@forEach)
                else -> return@forEach
            }
            //if (beanAnnotatedClassSymbol !is FirClassLikeSymbol<*>) return@forEach

            val beanAnnotation = beanAnnotatedSymbol.getAnnotationByClassId(
                ClassId.topLevel(FqName(Bean::class.qualifiedName!!)),
                session
            ) ?: return@forEach

            val nameArgument = beanAnnotation.getAnnotationFieldValue(Bean::name.name)

            // Removing bean generated by ANNOTATION with same FQN as this should be impossible
            //beans.removeAll { it.source == BeanSource.ANNOTATION && it.fqName == fqName && it.beanCreationMethod == beanCreationMethod }

            beans.add(BeanConfigInternal(
                name = if (nameArgument.isNullOrBlank()) getDefaultBeanName(beanAnnotatedSymbol)!! else nameArgument,
                fqName = fqName,
                source = BeanSource.ANNOTATION,
                beanCreationMethod = beanCreationMethod,
            ).apply {
                when (beanAnnotatedSymbol) {
                    is FirClassLikeSymbol -> originFqName = fqName
                    is FirFunctionSymbol ->
                        originFqName = beanAnnotatedSymbol.packageFqName().asString() + "." + beanAnnotatedSymbol.name

                }
            })
        }

        return createTopLevelClass(
            classId = managerClassId,
            key = KWireDeclarationKey,
            classKind = ClassKind.OBJECT
        ).symbol
    }

    /**
     * Called with names from [getCallableNamesForClass] [callableId.callableName]
     */
    override fun generateProperties(
        callableId: CallableId,
        context: MemberGenerationContext?
    ): List<FirPropertySymbol> {
        val owner = context?.owner ?: return emptyList()

        return listOf(
            createMemberProperty(
                owner = owner,
                key = KWireDeclarationKey,
                name = callableId.callableName,
                returnType = session.getClassSymbolFromFqn(beans.find { it.name == callableId.callableName.identifier }!!.fqName)!!.constructType()
            ).symbol
        )
    }

    /**
     * Compiler calls this method for every class
     * @return additional names of callable names (properties, functions) etc, these will be used to call [generateProperties] [generateFunctions]
     *
     */
    override fun getCallableNamesForClass(classSymbol: FirClassSymbol<*>, context: MemberGenerationContext): Set<Name> {
        if (classSymbol.classId != managerClassId)
            return emptySet()

        return beans.map {
            Name.identifier(it.name)
        }.toSet()
    }

    /**
     * Return top level classes to generate, these will be passed into [generateTopLevelClassLikeDeclaration]
     */
    @OptIn(ExperimentalTopLevelDeclarationsGenerationApi::class)
    override fun getTopLevelClassIds(): Set<ClassId> {
        return setOf(managerClassId)
    }

    override fun hasPackage(packageFqName: FqName): Boolean {
        return packageFqName == managerClassId.packageFqName
    }
}